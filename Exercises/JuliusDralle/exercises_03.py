# PART 1:
# Write a class for a French deck of cards (2-Ace of diamonds, hearts, spades, clubs).
# The deck of cards should behave like a sequence.
# When initialized the cards should all be in a well-defined order (2-Ace of each suite, suites in the order above
# I should be able to index into the deck to retrieve one card.
# I should be able to iterate over all cards in the deck.
# Printing a cards string representation should give me a nice, 
# readable description of that card.

cardtype_dict = {
    "02" : "2",
    "03" : "3",
    "04" : "4",
    "05" : "5",
    "06" : "6",
    "07" : "7",
    "08" : "8",
    "09" : "9",
    "10" : "10",
    "11" : "Jack",
    "12" : "Queen",
    "13" : "King",
    "01" : "Ace"
}
suits_dict = {
    "01" : "Diamonds",
    "02" : "Hearts",
    "03" : "Spades",
    "04" : "Clubs"
}

description_dict = {# COPYRIGHT INFORMATION: Following return values are generated by ChatGPT | OpenAI
    "01" : "Das Ass (Ace): Das Ass steht für das höchste Potenzial und die unbegrenzten Möglichkeiten. Mit seiner einsamen Spitzenposition erinnert es uns daran, dass wir die Fähigkeit haben, jede Herausforderung zu meistern.",
    "02" : "Die Zwei (2): Wie ein Paar, das sich eng umschlungen hält, symbolisiert die Zwei die Bindungen und Beziehungen, die unser Leben bereichern. Sie erinnert uns daran, dass Zusammenarbeit und Harmonie oft der Schlüssel zum Erfolg sind.",
    "03" : "Die Drei (3): Die Drei steht für Kreativität, Wachstum und Fülle. Wie die Blütenblätter einer Blume erinnert sie uns daran, dass unser Leben in stetigem Wandel ist und dass wir stets die Möglichkeit haben, Neues zu erschaffen.",
    "04" : "Die Vier (4): Die Vier symbolisiert Stabilität und Festigkeit. Wie die vier Himmelsrichtungen ist sie ein Anker in stürmischen Zeiten, der uns Sicherheit und Geborgenheit verleiht.",
    "05" : "Die Fünf (5): Die Fünf steht für Abenteuer und Veränderung. Wie die fünf Finger an einer Hand erinnert sie uns daran, dass wir die Welt erkunden und uns neuen Erfahrungen öffnen sollten.",
    "06" : "Die Sechs (6): Die Sechs symbolisiert Harmonie und Ausgewogenheit. Wie die Seiten eines Würfels erinnert sie uns daran, dass wir unser Leben in Balance halten sollten, um inneren Frieden zu finden.",
    "07" : "Die Sieben (7): Die Sieben steht für Glück und Wohlstand. Wie die Tage einer Woche erinnert sie uns daran, dass das Leben voller Chancen und Möglichkeiten steckt, die darauf warten, genutzt zu werden.",
    "08" : "Die Acht (8): Die Acht symbolisiert Fülle und Überfluss. Wie die Unendlichkeitsschleife erinnert sie uns daran, dass wir nie aufhören sollten, nach Erfolg und Wohlstand zu streben.",
    "09" : "Die Neun (9): Die Neun steht für Vollendung und Erfüllung. Wie die Monate in einem Jahr erinnert sie uns daran, dass wir unsere Ziele erreichen können, wenn wir hart arbeiten und Ausdauer zeigen.",
    "10" : "Die Zehn (10): Die Zehn symbolisiert Vollständigkeit und Erfolg. Wie die Finger an unseren Händen erinnert sie uns daran, dass wir alle Ressourcen zur Verfügung haben, um unsere Träume zu verwirklichen.",
    "11" : "Der Bube (Jack): Der Bube verkörpert Jugend und Abenteuerlust. Wie ein mutiger Held auf einer Reise erinnert er uns daran, dass wir Risiken eingehen und die Welt entdecken sollten.",
    "12" : "Die Dame (Queen): Die Dame steht für Anmut und Weisheit. Wie eine Königin auf ihrem Thron erinnert sie uns daran, dass wir unser Leben mit Würde und Klugheit führen sollten.",
    "12" : "Der König (King): Der König symbolisiert Macht und Autorität. Wie ein weiser Herrscher erinnert er uns daran, Verantwortung zu übernehmen und unser Leben zu regieren."
}

class DeckOfCards:
    """
    This Class is a whole Bundle of Cards. It does not take any argument but acts as a standard 52 cards french deck. 
    It requires the global dictionaries: cardtype_dict, suits_dict, description_dict
    Those dictionaries do not come with this class itself
    """
    list_of_cards = []
    def __init__(self):
        for iterator_through_suits in suits_dict:
            for iterator_through_cardstype in cardtype_dict:
                self.list_of_cards.append(Card(iterator_through_suits, iterator_through_cardstype))

    def __getitem__(self, index):
        return(self.list_of_cards[index])

    def __iter__(self):
        return(i for i in self.list_of_cards)


    def print_cards(self):
        for iterator_through_cards in self.list_of_cards:
            iterator_through_cards.print_value()
        return 0






class Card: 
    """
    This is the Card's class. It is a single card which does only contain two values for the card type and the suite it is in. Cards are the elements a card-deck is made of
    """ 
    def __init__(self, card_suite_id, card_type_id):
        self.card_suite = card_suite_id
        self.card_type = card_type_id

    def __str__(self):
        return(description_dict[self.card_type])
    
    def print_value(self):
        print(f"This card is a \t{cardtype_dict[self.card_type]} \tin this suite: {suits_dict[self.card_suite]}")

    def get_value(self):
        return(cardtype_dict[self.card_type], suits_dict[self.card_suite])
    
    

meinKartendeck = DeckOfCards()
print(meinKartendeck[2])
 


# PART 2:
# Create a second class that represents a deck of cards usable for Skat -- it should only contain cards from 7 upwards.
# It should offer all the same functionality of the first class.

class DeckOfSkatCards:
    """
    The DeckOfSkatCards class is a Deck of cards for a Skat game. It only contains cards from the 7 up beginning
    """
    wanted_cards = ["07","08","09","10","11","12","13","01"]
    list_of_cards = []
    def __init__(self):
        for iterator_through_suits in suits_dict:
            for iterator_through_cardstype in self.wanted_cards:
                self.list_of_cards.append(Card(iterator_through_suits, iterator_through_cardstype))

    def __getitem__(self, index):
        return(self.list_of_cards[index])

    def __iter__(self):
        return(i for i in self.list_of_cards)


    def print_cards(self):
        for iterator_through_cards in self.list_of_cards:
            iterator_through_cards.print_value()
        return 0

MeinSkatDeck = DeckOfSkatCards()
MeinSkatDeck.print_cards()

# Write some code to test the functionality of both kinds of decks. (You can use `assert` to make sure your classes behave the way you expect them to.)


# PART 3:
# write a function that accepts two numbers, a lower bound and an upper bound.
# the function should then return the count of all numbers that meet certain criteria:
# - they are within the (left-inclusive and right-exclusive) bounds passed to the function
# - there is at least one group of exactly two adjacent digits within the number which are the same (like 33 in 123345)
# - digits only increase going from left to right
#
# Examples:
# - 123345 is a valid number
# - 123341 is not a valid number, as the digits do not increase from left to right
# - 123334 is not a valid number as there is no group of exactly two repeated digits
# - 111334 is a valid number. while there are three 1s, there is also a group of exactly two 3s.
# - 112233 is a valid number. At least one group of two is fulfilled, there is no maximum to the number of such groups.
#
# run your function with the lower bound `134564` and the upper bound `585159`. Note the resulting count
# in your pull request, please.

def numberCriteriaCheckerCounter(bound_lower, bound_higher):
    """
    This function takes two arguments: lower bound and higher bound, both as int
    This function first tests if a number contains a adjacent pair of digits.
    After that is tests if the number is sorted already
    If both tests come out positive, the amount of numbers in the bounds is being represented
    """
    bound_lower = int(bound_lower)
    bound_higher = int(bound_higher)
    validNumbers = []
    for iterator_numbers in range(bound_lower, bound_higher):
        number_string = str(iterator_numbers)
        number_string_sorted = "".join(sorted(number_string))
        adjacence = False
        isValid = False
        for iterator_charsInString in range(0, len(number_string)):
            if iterator_charsInString > 0:
                if number_string[iterator_charsInString - 1] == number_string[iterator_charsInString] and number_string.count(number_string[iterator_charsInString]) == 2:
                    adjacence = True
                    #print("adjacence given")
        if adjacence == True:
            if number_string == number_string_sorted:
                isValid = True
        if isValid:
            validNumbers.append(number_string)
    return(len(validNumbers))

print(numberCriteriaCheckerCounter(134564,585159))
# The Result to this is: 1306